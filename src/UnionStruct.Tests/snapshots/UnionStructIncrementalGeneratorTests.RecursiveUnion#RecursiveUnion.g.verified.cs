//HintName: RecursiveUnion.g.cs
// <auto-generated>
// This code was generated by UnionStruct.
// </auto-generated>

#nullable enable

namespace Tests;

[global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Explicit)]
internal partial struct RecursiveUnion : global::System.IEquatable<RecursiveUnion>
{
	public const global::System.Int32 EmptyIndex = 0;
	public const global::System.Int32 NodeIndex = 1;

	[global::System.Runtime.InteropServices.FieldOffset(0)]
	public readonly global::System.Int32 CaseIndex;

	[global::System.Runtime.InteropServices.FieldOffset(4)]
	public NodeCase NodeData = default!;

	private RecursiveUnion(global::System.Int32 caseIndex)
	{
		CaseIndex = caseIndex;
	}

	public bool IsEmpty => CaseIndex == EmptyIndex;
	public bool IsNode => CaseIndex == NodeIndex;

	public static partial RecursiveUnion Empty(
	)
	{
		RecursiveUnion ___factoryReturnValue = new(EmptyIndex);
		return ___factoryReturnValue;
	}

	public static partial RecursiveUnion Node(
		Tests.RecursiveUnion @left,
		Tests.RecursiveUnion @right
	)
	{
		RecursiveUnion ___factoryReturnValue = new(NodeIndex);
		___factoryReturnValue.NodeData.Left = @left;
		___factoryReturnValue.NodeData.Right = @right;
		return ___factoryReturnValue;
	}

	public void Switch(
		global::System.Action @empty,
		global::System.Action<Tests.RecursiveUnion, Tests.RecursiveUnion> @node
	)
	{
		switch (CaseIndex)
		{
			case EmptyIndex: @empty.Invoke(); break;
			case NodeIndex: @node.Invoke(NodeData.Left, NodeData.Right); break;
			default: throw new global::System.Diagnostics.UnreachableException($"Invalid case index: {CaseIndex}.");
		}
	}

	public TMatchOut Match<TMatchOut>(
		global::System.Func<TMatchOut> @empty,
		global::System.Func<Tests.RecursiveUnion, Tests.RecursiveUnion, TMatchOut> @node
	)
	{
		return CaseIndex switch
		{
			EmptyIndex => @empty.Invoke(),
			NodeIndex => @node.Invoke(NodeData.Left, NodeData.Right),
			_ => throw new global::System.Diagnostics.UnreachableException($"Invalid case index: {CaseIndex}."),
		};
	}

	public override global::System.String ToString()
	{
		return CaseIndex switch
		{
			EmptyIndex => "Empty",
			NodeIndex => $"Node {{ Left = {NodeData.Left}, Right = {NodeData.Right} }}",
			_ => throw new global::System.Diagnostics.UnreachableException($"Invalid case index: {CaseIndex}."),
		};
	}

	public static bool operator !=(RecursiveUnion left, RecursiveUnion right)
	{
		return !(left == right);
	}

	public static bool operator ==(RecursiveUnion left, RecursiveUnion right)
	{
		return left.Equals(right);
	}

	public override global::System.Int32 GetHashCode()
	{
		return CaseIndex switch
		{
			EmptyIndex => unchecked ( EmptyIndex ),
			NodeIndex => unchecked ( NodeIndex * -1521134295 + (NodeData.Left == null ? 0 : global::System.Collections.Generic.EqualityComparer<Tests.RecursiveUnion>.Default.GetHashCode(NodeData.Left)) * -1521134295 + (NodeData.Right == null ? 0 : global::System.Collections.Generic.EqualityComparer<Tests.RecursiveUnion>.Default.GetHashCode(NodeData.Right)) ),
			_ => 2,
		};
	}

	public override global::System.Boolean Equals(global::System.Object? obj)
	{
		return obj is RecursiveUnion && Equals((RecursiveUnion)obj);
	}

	public global::System.Boolean Equals(RecursiveUnion other)
	{
		return CaseIndex == other.CaseIndex && CaseIndex switch
		{
			EmptyIndex => true,
			NodeIndex => global::System.Collections.Generic.EqualityComparer<Tests.RecursiveUnion>.Default.Equals(NodeData.Left, other.NodeData.Left) && global::System.Collections.Generic.EqualityComparer<Tests.RecursiveUnion>.Default.Equals(NodeData.Right, other.NodeData.Right),
			_ => true,
		};
	}

	public struct NodeCase
	{
		public Tests.RecursiveUnion Left;

		public Tests.RecursiveUnion Right;

	}

}
