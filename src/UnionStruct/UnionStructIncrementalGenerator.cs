using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;
using UnionStruct.Internals;
using UnionStruct.Model;

namespace UnionStruct;

[Generator]
public class UnionStructIncrementalGenerator : IIncrementalGenerator
{
	private const string _namespace = "UnionStruct";
	private const string _unionAttributeName = "UnionAttribute";
	private const string _unionCaseAttributeName = "UnionCaseAttribute";

	private const string _unionAttributeSourceCode =
		$"""
		 // <auto-generated/>

		 namespace {_namespace};

		 [global::System.AttributeUsage(global::System.AttributeTargets.Struct)]
		 public sealed class {_unionAttributeName}(global::System.Boolean IncludeEmptyCase) : global::System.Attribute;
		 """;

	private const string _unionCaseAttributeSourceCode =
		$"""
		 // <auto-generated/>

		 namespace {_namespace};

		 [global::System.AttributeUsage(global::System.AttributeTargets.Struct, AllowMultiple = true)]
		 public sealed class {_unionCaseAttributeName}<T> : global::System.Attribute where T : unmanaged;
		 """;

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{_unionAttributeName}.g.cs", SourceText.From(_unionAttributeSourceCode, Encoding.UTF8)));
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{_unionCaseAttributeName}.g.cs", SourceText.From(_unionCaseAttributeSourceCode, Encoding.UTF8)));

		// ! LINQ is used to filter out null values.
		IncrementalValuesProvider<UnionModel> provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				(sn, _) => sn is RecordDeclarationSyntax recordDeclarationSyntax && recordDeclarationSyntax.ClassOrStructKeyword.IsKind(SyntaxKind.StructKeyword),
				(ctx, _) => GetUnionModel(ctx))
			.Where(um => um != null)
			.Select((um, _) => um!);

		context.RegisterSourceOutput(
			context.CompilationProvider.Combine(provider.Collect()),
			(ctx, t) => GenerateUnionStruct(ctx, t.Left, t.Right));
	}

	private static UnionModel? GetUnionModel(GeneratorSyntaxContext context)
	{
		RecordDeclarationSyntax recordDeclarationSyntax = (RecordDeclarationSyntax)context.Node;

		bool isUnion = false;
		bool hasEmptyCase = false;
		List<UnionCaseModel> cases = [];

		foreach (AttributeListSyntax attributeListSyntax in recordDeclarationSyntax.AttributeLists)
		{
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
			{
				if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
					continue;

				string attributeName = attributeSymbol.ContainingType.ToDisplayString();

				if (attributeName == $"{_namespace}.{_unionAttributeName}")
				{
					if (attributeSyntax.ArgumentList == null)
						throw new InvalidOperationException("UnionAttribute must have an argument.");

					ExpressionSyntax exp = attributeSyntax.ArgumentList.Arguments[0].Expression;
					if (exp is not LiteralExpressionSyntax literalExpressionSyntax)
						throw new InvalidOperationException("UnionAttribute argument must be a literal.");

					isUnion = true;
					hasEmptyCase = literalExpressionSyntax.Token.Text switch
					{
						"true" => true,
						"false" => false,
						_ => throw new InvalidOperationException($"Invalid value for union attribute: {literalExpressionSyntax.Token.Text}"),
					};
				}
				else if (attributeName.StartsWith($"{_namespace}.{_unionCaseAttributeName}", StringComparison.Ordinal))
				{
					GenericNameSyntax genericNameSyntax = (GenericNameSyntax)attributeSyntax.Name;
					TypeSyntax type = genericNameSyntax.TypeArgumentList.Arguments[0];
					if (ModelExtensions.GetTypeInfo(context.SemanticModel, type).Type is INamedTypeSymbol namedTypeSymbol)
						cases.Add(new UnionCaseModel(namedTypeSymbol));
				}
			}
		}

		return isUnion ? new UnionModel(recordDeclarationSyntax, hasEmptyCase, cases) : null;
	}

	private static void GenerateUnionStruct(SourceProductionContext context, Compilation compilation, ImmutableArray<UnionModel> unionModels)
	{
		foreach (UnionModel unionModel in unionModels)
		{
			SemanticModel semanticModel = compilation.GetSemanticModel(unionModel.RecordDeclarationSyntax.SyntaxTree);
			if (ModelExtensions.GetDeclaredSymbol(semanticModel, unionModel.RecordDeclarationSyntax) is not INamedTypeSymbol structSymbol)
				continue;

			string namespaceName = structSymbol.ContainingNamespace.ToDisplayString();
			string structName = unionModel.StructName;
			string accessibility = structSymbol.DeclaredAccessibility.ToString().ToLowerInvariant();

			CodeWriter writer = new();
			writer.WriteLine($"namespace {namespaceName};");
			writer.WriteLine();
			writer.WriteLine("[global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Explicit)]");
			writer.WriteLine($"{accessibility} partial record struct {structName}");
			writer.StartBlock();
			GenerateUnionCaseConstants(writer, unionModel);
			writer.WriteLine();
			writer.WriteLine("[global::System.Runtime.InteropServices.FieldOffset(0)]");
			writer.WriteLine("public readonly global::System.Int32 CaseIndex;");
			writer.WriteLine();
			GenerateUnionCaseDataFields(writer, unionModel);
			writer.WriteLine($"private {structName}(global::System.Int32 caseIndex)");
			writer.StartBlock();
			writer.WriteLine("CaseIndex = caseIndex;");
			writer.EndBlock();
			writer.WriteLine();
			GenerateIsMethods(writer, unionModel);
			writer.WriteLine();
			GenerateFactoryMethods(writer, unionModel);
			GenerateSwitchMethod(writer, unionModel);
			writer.WriteLine();
			GenerateMatchMethod(writer, unionModel);
			writer.WriteLine();
			GenerateToStringMethod(writer, unionModel);
			writer.EndBlock();

			context.AddSource($"{structName}.g.cs", SourceText.From(SourceBuilderUtils.Build(writer.ToString()), Encoding.UTF8));
		}
	}

	private static void GenerateUnionCaseConstants(CodeWriter writer, UnionModel unionModel)
	{
		int index = 0;
		if (unionModel.HasEmptyCase)
			writer.WriteLine($"public const global::System.Int32 EmptyIndex = {index++};");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			writer.WriteLine($"public const global::System.Int32 {unionCaseModel.Type.Name}Index = {index++};");
	}

	private static void GenerateUnionCaseDataFields(CodeWriter writer, UnionModel unionModel)
	{
		const int fieldOffset = 4;

		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
		{
			writer.WriteLine($"[global::System.Runtime.InteropServices.FieldOffset({fieldOffset})]");
			writer.WriteLine($"public {unionCaseModel.GetFullyQualifiedTypeName()} {unionCaseModel.Type.Name}Data;");
			writer.WriteLine();
		}
	}

	private static void GenerateIsMethods(CodeWriter writer, UnionModel unionModel)
	{
		if (unionModel.HasEmptyCase)
			writer.WriteLine("public bool IsEmpty => CaseIndex == EmptyIndex;");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			writer.WriteLine($"public bool Is{unionCaseModel.Type.Name} => CaseIndex == {unionCaseModel.Type.Name}Index;");
	}

	private static void GenerateFactoryMethods(CodeWriter writer, UnionModel unionModel)
	{
		if (unionModel.HasEmptyCase)
		{
			writer.WriteLine($"public static {unionModel.StructName} Empty()");
			writer.StartBlock();
			writer.WriteLine($"return new {unionModel.StructName}(EmptyIndex);");
			writer.EndBlock();
			writer.WriteLine();
		}

		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
		{
			writer.WriteLine($"public static {unionModel.StructName} {unionCaseModel.Type.Name}({unionCaseModel.GetFullyQualifiedTypeName()} {unionCaseModel.GetParameterName()})");
			writer.StartBlock();
			writer.WriteLine($"return new {unionModel.StructName}({unionCaseModel.Type.Name}Index)");
			writer.StartBlock();
			writer.WriteLine($"{unionCaseModel.Type.Name}Data = {unionCaseModel.GetParameterName()},");
			writer.EndBlockWithSemicolon();
			writer.EndBlock();
			writer.WriteLine();
		}
	}

	private static void GenerateSwitchMethod(CodeWriter writer, UnionModel unionModel)
	{
		List<string> parameters = [];
		if (unionModel.HasEmptyCase)
			parameters.Add("global::System.Action empty");
		parameters.AddRange(unionModel.Cases.Select(ucm => $"global::System.Action<{ucm.GetFullyQualifiedTypeName()}> {ucm.GetParameterName()}"));

		writer.WriteLine("public void Switch(");

		writer.StartIndent();
		for (int i = 0; i < parameters.Count; i++)
			writer.WriteLine($"{parameters[i]}{(i < parameters.Count - 1 ? "," : ")")}");
		writer.EndIndent();

		writer.StartBlock();
		writer.WriteLine("switch (CaseIndex)");
		writer.StartBlock();
		if (unionModel.HasEmptyCase)
			writer.WriteLine("case EmptyIndex: empty.Invoke(); break;");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			writer.WriteLine($"case {unionCaseModel.Type.Name}Index: {unionCaseModel.GetParameterName()}.Invoke({unionCaseModel.Type.Name}Data); break;");
		writer.WriteLine("default: throw new global::System.Diagnostics.UnreachableException($\"Invalid case index: {CaseIndex}.\");");
		writer.EndBlock();
		writer.EndBlock();
	}

	private static void GenerateMatchMethod(CodeWriter writer, UnionModel unionModel)
	{
		List<string> parameters = [];
		if (unionModel.HasEmptyCase)
			parameters.Add("global::System.Func<T> empty");
		parameters.AddRange(unionModel.Cases.Select(ucm => $"global::System.Func<{ucm.GetFullyQualifiedTypeName()}, T> {ucm.GetParameterName()}"));

		writer.WriteLine("public T Match<T>(");

		writer.StartIndent();
		for (int i = 0; i < parameters.Count; i++)
			writer.WriteLine($"{parameters[i]}{(i < parameters.Count - 1 ? "," : ")")}");
		writer.EndIndent();

		writer.WriteLine(")");
		writer.StartBlock();
		writer.WriteLine("return CaseIndex switch");
		writer.StartBlock();
		if (unionModel.HasEmptyCase)
			writer.WriteLine("EmptyIndex => empty.Invoke(),");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			writer.WriteLine($"{unionCaseModel.Type.Name}Index => {unionCaseModel.GetParameterName()}.Invoke({unionCaseModel.Type.Name}Data),");
		writer.WriteLine("_ => throw new global::System.Diagnostics.UnreachableException($\"Invalid case index: {CaseIndex}.\")");
		writer.EndBlockWithSemicolon();
		writer.EndBlock();
	}

	private static void GenerateToStringMethod(CodeWriter writer, UnionModel unionModel)
	{
		writer.WriteLine("public override global::System.String ToString()");
		writer.StartBlock();
		writer.WriteLine("return CaseIndex switch");
		writer.StartBlock();
		if (unionModel.HasEmptyCase)
			writer.WriteLine("EmptyIndex => \"Empty\",");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			writer.WriteLine($"{unionCaseModel.Type.Name}Index => {unionCaseModel.Type.Name}Data.ToString(),");
		writer.WriteLine("_ => throw new global::System.Diagnostics.UnreachableException($\"Invalid case index: {CaseIndex}.\")");
		writer.EndBlockWithSemicolon();
		writer.EndBlock();
	}
}
