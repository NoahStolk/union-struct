using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;
using UnionStruct.Model;

namespace UnionStruct;

[Generator]
public class UnionStructIncrementalGenerator : IIncrementalGenerator
{
	private const string _namespace = "UnionStruct";
	private const string _unionAttributeName = "UnionAttribute";
	private const string _unionCaseAttributeName = "UnionCaseAttribute";

	private const string _unionAttributeSourceCode = $"""
		// <auto-generated/>

		namespace {_namespace};

		[global::System.AttributeUsage(global::System.AttributeTargets.Struct)]
		public sealed class {_unionAttributeName}(global::System.Boolean IncludeEmptyCase) : global::System.Attribute;
		""";

	private const string _unionCaseAttributeSourceCode = $"""
		// <auto-generated/>

		namespace {_namespace};

		[global::System.AttributeUsage(global::System.AttributeTargets.Struct, AllowMultiple = true)]
		public sealed class {_unionCaseAttributeName}<T> : global::System.Attribute where T : unmanaged;
		""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{_unionAttributeName}.g.cs", SourceText.From(_unionAttributeSourceCode, Encoding.UTF8)));
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{_unionCaseAttributeName}.g.cs", SourceText.From(_unionCaseAttributeSourceCode, Encoding.UTF8)));

		// ! LINQ is used to filter out null values.
		IncrementalValuesProvider<UnionModel> provider = context.SyntaxProvider
			.CreateSyntaxProvider(
				(sn, _) => sn is RecordDeclarationSyntax recordDeclarationSyntax && recordDeclarationSyntax.ClassOrStructKeyword.IsKind(SyntaxKind.StructKeyword),
				(ctx, _) => GetUnionModel(ctx))
			.Where(um => um != null)
			.Select((um, _) => um!);

		context.RegisterSourceOutput(
			context.CompilationProvider.Combine(provider.Collect()),
			(ctx, t) => GenerateUnionStruct(ctx, t.Left, t.Right));
	}

	private static UnionModel? GetUnionModel(GeneratorSyntaxContext context)
	{
		RecordDeclarationSyntax recordDeclarationSyntax = (RecordDeclarationSyntax)context.Node;

		bool isUnion = false;
		bool hasEmptyCase = false;
		List<UnionCaseModel> cases = [];

		foreach (AttributeListSyntax attributeListSyntax in recordDeclarationSyntax.AttributeLists)
		{
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
			{
				if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
					continue;

				string attributeName = attributeSymbol.ContainingType.ToDisplayString();

				if (attributeName == $"{_namespace}.{_unionAttributeName}")
				{
					if (attributeSyntax.ArgumentList == null)
						throw new InvalidOperationException("UnionAttribute must have an argument.");

					ExpressionSyntax exp = attributeSyntax.ArgumentList.Arguments[0].Expression;
					if (exp is not LiteralExpressionSyntax literalExpressionSyntax)
						throw new InvalidOperationException("UnionAttribute argument must be a literal.");

					isUnion = true;
					hasEmptyCase = literalExpressionSyntax.Token.Text switch
					{
						"true" => true,
						"false" => false,
						_ => throw new InvalidOperationException($"Invalid value for union attribute: {literalExpressionSyntax.Token.Text}"),
					};
				}
				else if (attributeName.StartsWith($"{_namespace}.{_unionCaseAttributeName}", StringComparison.Ordinal))
				{
					GenericNameSyntax genericNameSyntax = (GenericNameSyntax)attributeSyntax.Name;
					TypeSyntax type = genericNameSyntax.TypeArgumentList.Arguments[0];
					if (ModelExtensions.GetTypeInfo(context.SemanticModel, type).Type is INamedTypeSymbol namedTypeSymbol)
						cases.Add(new UnionCaseModel(namedTypeSymbol));
				}
			}
		}

		return isUnion ? new UnionModel(recordDeclarationSyntax, hasEmptyCase, cases) : null;
	}

	private static void GenerateUnionStruct(SourceProductionContext context, Compilation compilation, ImmutableArray<UnionModel> unionModels)
	{
		foreach (UnionModel unionModel in unionModels)
		{
			SemanticModel semanticModel = compilation.GetSemanticModel(unionModel.RecordDeclarationSyntax.SyntaxTree);
			if (ModelExtensions.GetDeclaredSymbol(semanticModel, unionModel.RecordDeclarationSyntax) is not INamedTypeSymbol structSymbol)
				continue;

			string namespaceName = structSymbol.ContainingNamespace.ToDisplayString();
			string structName = unionModel.StructName;
			string accessibility = structSymbol.DeclaredAccessibility.ToString().ToLowerInvariant();

			string code = $$"""
// <auto-generated/>

namespace {{namespaceName}};

[global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Explicit)]
{{accessibility}} partial record struct {{structName}}
{
{{GenerateUnionCaseConstants(unionModel)}}

    [global::System.Runtime.InteropServices.FieldOffset(0)]
    public readonly global::System.Int32 CaseIndex;

{{GenerateUnionCaseDataFields(unionModel)}}
    private {{structName}}(global::System.Int32 caseIndex)
    {
        CaseIndex = caseIndex;
    }

{{GenerateIsMethods(unionModel)}}

{{GenerateFactoryMethods(unionModel)}}

{{GenerateSwitchMethod(unionModel)}}

{{GenerateMatchMethod(unionModel)}}

{{GenerateToStringMethod(unionModel)}}

}

""";

			context.AddSource($"{structName}.g.cs", SourceText.From(code, Encoding.UTF8));
		}
	}

	private static string GenerateUnionCaseConstants(UnionModel unionModel)
	{
		StringBuilder builder = new();

		int index = 0;
		if (unionModel.HasEmptyCase)
			builder.AppendLine($"\tpublic const global::System.Int32 EmptyIndex = {index++};");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			builder.AppendLine($"\tpublic const global::System.Int32 {unionCaseModel.Type.Name}Index = {index++};");

		return builder.ToString();
	}

	private static string GenerateUnionCaseDataFields(UnionModel unionModel)
	{
		const int fieldOffset = 4;

		StringBuilder builder = new();

		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
		{
			builder.AppendLine($"\t[global::System.Runtime.InteropServices.FieldOffset({fieldOffset})]");
			builder.AppendLine($"\tpublic {unionCaseModel.GetFullyQualifiedTypeName()} {unionCaseModel.Type.Name}Data;");
			builder.AppendLine();
		}

		return builder.ToString();
	}

	private static string GenerateIsMethods(UnionModel unionModel)
	{
		StringBuilder builder = new();

		if (unionModel.HasEmptyCase)
			builder.AppendLine("\tpublic bool IsEmpty => CaseIndex == EmptyIndex;");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			builder.AppendLine($"\tpublic bool Is{unionCaseModel.Type.Name} => CaseIndex == {unionCaseModel.Type.Name}Index;");

		return builder.ToString();
	}

	private static string GenerateFactoryMethods(UnionModel unionModel)
	{
		StringBuilder builder = new();

		if (unionModel.HasEmptyCase)
		{
			builder.AppendLine($"\tpublic static {unionModel.StructName} Empty()");
			builder.AppendLine("\t{");
			builder.AppendLine($"\t\treturn new {unionModel.StructName}(EmptyIndex);");
			builder.AppendLine("\t}");
			builder.AppendLine("\n");
		}

		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
		{
			builder.AppendLine($"\tpublic static {unionModel.StructName} {unionCaseModel.Type.Name}({unionCaseModel.GetFullyQualifiedTypeName()} {unionCaseModel.GetParameterName()})");
			builder.AppendLine("\t{");
			builder.AppendLine($"\t\treturn new {unionModel.StructName}({unionCaseModel.Type.Name}Index)");
			builder.AppendLine("\t\t{");
			builder.AppendLine($"\t\t\t{unionCaseModel.Type.Name}Data = {unionCaseModel.GetParameterName()},");
			builder.AppendLine("\t\t};");
			builder.AppendLine("\t}");
			builder.AppendLine("\n");
		}

		return builder.ToString();
	}

	private static string GenerateSwitchMethod(UnionModel unionModel)
	{
		StringBuilder builder = new();

		List<string> parameters = [];
		if (unionModel.HasEmptyCase)
			parameters.Add("global::System.Action empty");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			parameters.Add($"global::System.Action<{unionCaseModel.GetFullyQualifiedTypeName()}> {unionCaseModel.GetParameterName()}");

		builder.AppendLine("\tpublic void Switch(");
		builder.AppendLine(string.Join(",\n", parameters));
		builder.AppendLine("\t)");
		builder.AppendLine("\t{");
		builder.AppendLine("\t\tswitch (CaseIndex)");
		builder.AppendLine("\t\t{");
		if (unionModel.HasEmptyCase)
			builder.AppendLine("\t\t\tcase EmptyIndex: empty.Invoke(); break;");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			builder.AppendLine($"\t\t\tcase {unionCaseModel.Type.Name}Index: {unionCaseModel.GetParameterName()}.Invoke({unionCaseModel.Type.Name}Data); break;");
		builder.AppendLine("\t\t\tdefault: throw new global::System.Diagnostics.UnreachableException($\"Invalid case index: {CaseIndex}.\");");
		builder.AppendLine("\t\t}");
		builder.AppendLine("\t}");

		return builder.ToString();
	}

	private static string GenerateMatchMethod(UnionModel unionModel)
	{
		StringBuilder builder = new();

		List<string> parameters = [];
		if (unionModel.HasEmptyCase)
			parameters.Add("global::System.Func<T> empty");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			parameters.Add($"global::System.Func<{unionCaseModel.GetFullyQualifiedTypeName()}, T> {unionCaseModel.GetParameterName()}");

		builder.AppendLine("\tpublic T Match<T>(");
		builder.AppendLine(string.Join(",\n", parameters));
		builder.AppendLine("\t)");
		builder.AppendLine("\t{");
		builder.AppendLine("\t\treturn CaseIndex switch");
		builder.AppendLine("\t\t{");
		if (unionModel.HasEmptyCase)
			builder.AppendLine("\t\t\tEmptyIndex => empty.Invoke(),");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			builder.AppendLine($"\t\t\t{unionCaseModel.Type.Name}Index => {unionCaseModel.GetParameterName()}.Invoke({unionCaseModel.Type.Name}Data),");
		builder.AppendLine("\t\t\t_ => throw new global::System.Diagnostics.UnreachableException($\"Invalid case index: {CaseIndex}.\")");
		builder.AppendLine("\t\t};");
		builder.AppendLine("\t}");

		return builder.ToString();
	}

	private static string GenerateToStringMethod(UnionModel unionModel)
	{
		StringBuilder builder = new();

		builder.AppendLine("\tpublic override global::System.String ToString()");
		builder.AppendLine("\t{");
		builder.AppendLine("\t\treturn CaseIndex switch");
		builder.AppendLine("\t\t{");
		if (unionModel.HasEmptyCase)
			builder.AppendLine("\t\t\tEmptyIndex => \"Empty\",");
		foreach (UnionCaseModel unionCaseModel in unionModel.Cases)
			builder.AppendLine($"\t\t\t{unionCaseModel.Type.Name}Index => {unionCaseModel.Type.Name}Data.ToString(),");
		builder.AppendLine("\t\t\t_ => throw new global::System.Diagnostics.UnreachableException($\"Invalid case index: {CaseIndex}.\")");
		builder.AppendLine("\t\t};");
		builder.AppendLine("\t}");

		return builder.ToString();
	}
}
